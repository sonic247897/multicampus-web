<<JSP - Java Server Page>>
- 클라이언트의 요청에 대해서 동적 컨텐츠를 생성해서 응답결과(html태그)를 만들어줄 때 
    사용하는 기술로 html문서에 화면을 구성하는 방법과 동일하게 작성하면 된다.
- 실행이 될 때 WAS 내부에 있는 JSP컨테이너(기능, 라이브러리)에 의해 서블릿으로 변환되어 실행이 되므로 
    자바코드를 사용할 수 있다.
- JSP는 서블릿에서 발생한 데이터를 화면에 출력하기 위해서 사용하는 기술이므로 자바코드를
    다양하게 많이 정의하지 않도록 구현해야 한다. (비지니스 로직과 화면단이 분리되도록)
- Lifecycle이 서블릿과 유사

C:\iot\work\webwork\.metadata\.plugins\org.eclipse.wst.server.core\
tmp0\work\Catalina\localhost\serverweb\org\apache\jsp\jspbasic 을 보면
jsp파일이 java파일로 변경되어서 저장되어 있고 컴파일된 class파일들이 있다.
 => _jspInit(), _jspDestroy() : 서블릿의 Lifecycle과 유사
 	_jspService : 서블릿의 서비스 메소드와 유사
	 	javax.servlet.jsp.JspWriter out = null; :출력 객체 생성
	 	out = pageContext.getOut();

1. JSP 스크립트 요소(scriptTest.jsp)
	1) 스크립트릿
		<%	%>
		=> 자바코드를 작성할 수 있는 스크립트 요소
		=> 문장의 끝에 반드시 ;을 추가해야 한다.(자바코드)
		=> 스크립트릿 요소는 여러 번 반복해서 정의할 수 있다.
		=> 사용을 지양한다.
			:서블릿이 공유하는 데이터를 꺼내서 출력하는 작업만 해야한다. 다른 로직은 구현X
		=> .java파일에서 할 수 있는 모든 작업을 할 수 있다.(메소드 선언, 클래스 선언 X)
		=> java.lang패키지 빼고 모두 import
		=> 스크립트릿 내부에서 정의하는 변수는 모두 _jspService() 메소드의 지역변수로 추가
	
	2) 선언문
		<%! %>
		=> jsp파일이 서블릿으로 변환될 때 서블릿 클래스의 멤버로 작성될 메소드나 변수를 정의(거의 사용 안함)
		
	3) 표현식
		<%= %>
		=> 동적으로 만들어진 컨텐츠를 구성하는 값을 출력하기 위해 사용하는 스크립트요소
		=> 서블릿으로 변환될 때 out.print()의 내부에 매개변수로 추가되므로 ;을 추가하지 않는다.
		
		[오류상황]
		<%= "test" ;%>	=============> out.print("test";)	: error!!!
			=> 표현식은 값을 출력하기 위해서 사용하므로 사용할 수 있는 타입이 제한적
			=> 기본형, String, 앞에 나열한 타입을 반환하는 메소드 호출문, 연산 (Sysout으로 출력할 수 있는 것들만)
		
2. 지시자		
3. JSP 내장객체
	=> jsp가 서블릿으로 변환될 때 jsp컨테이너에 의해서 _jspService()메소드 내부에 추가된 지역변수
	  (jsp문서 내부에서 변수 선언하지 않고 사용할 수 있다.)
	    객체명은 컨테이너가 자동생성 해준 이름이므로 반드시 정해진 이름으로 사용해야 한다.
	   request: HttpServletRequest
	   response: HttpServletResponse
	   session: HttpSession
	   application: ServletContext
	   
	   1) request객체
	   	: 클라이언트의 요청정보를 담고 있는 객체
	   	 서블릿으로부터 전달받아 사용한다.
	   	 => 서블릿에서 사용하는 모든것을 사용할 수 있다. 
	   
	
4. JSP 액션태그
5. EL & JSTL

